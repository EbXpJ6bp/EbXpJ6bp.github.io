<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memo on EbXpJ6bp&#39;s Blog</title>
    <link>http://ebxpj6bp.github.io/tags/memo/</link>
    <description>Recent content in Memo on EbXpJ6bp&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 29 Nov 2015 21:18:13 +0900</lastBuildDate>
    <atom:link href="http://ebxpj6bp.github.io/tags/memo/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C-COOLをMarkdownに書き下ろした</title>
      <link>http://ebxpj6bp.github.io/post/2015-11-29/</link>
      <pubDate>Sun, 29 Nov 2015 21:18:13 +0900</pubDate>
      
      <guid>http://ebxpj6bp.github.io/post/2015-11-29/</guid>
      <description>

&lt;p&gt;ごめんなさい&lt;/p&gt;

&lt;h3 id=&#34;元サイト:5e035f2d61dc09b3e21b31b0970c5394&#34;&gt;元サイト&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://www.sage-p.com/process/cool.htm&#34;&gt;http://www.sage-p.com/process/cool.htm&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;サイト内:5e035f2d61dc09b3e21b31b0970c5394&#34;&gt;サイト内&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://ebxpj6bp.github.io/COOL/&#34;&gt;http://ebxpj6bp.github.io/COOL/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;マークダウン:5e035f2d61dc09b3e21b31b0970c5394&#34;&gt;マークダウン&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/EbXpJ6bp/C-COOL/blob/master/COOL/COOL.md&#34;&gt;https://github.com/EbXpJ6bp/C-COOL/blob/master/COOL/COOL.md&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>備忘録。</title>
      <link>http://ebxpj6bp.github.io/post/2015-11-26/</link>
      <pubDate>Thu, 26 Nov 2015 17:02:55 +0900</pubDate>
      
      <guid>http://ebxpj6bp.github.io/post/2015-11-26/</guid>
      <description>

&lt;p&gt;C言語でオブジェクト指向したい備忘録。本当にそれだけ&lt;/p&gt;

&lt;h2 id=&#34;オブジェクト指向と手続き型プログラミングの違い:81f2082d0c43803c7b90cee6328c4723&#34;&gt;オブジェクト指向と手続き型プログラミングの違い&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;手続き型プログラミングでは、プログラミングはデータ構造とルーチンの集合に分割される。一方オブジェクト指向プログラミングでは、プログラミングはオブジェクトに分割される。&lt;/p&gt;

&lt;p&gt;一般にオブジェクト指向プログラミングの方が理解しやすいと言われている。その理由として、オブジェクト指向が人間の精神モデルの認知手法に近いからだという説もあるが、心理学が人間の認知モデルを完全には明確化できていない現時点では非常に不確かである。蒸気機関が発明されたとき、人間の精神は蒸気機関と比較された。コンピュータが発明されたとき、人間の精神はそれと比較された。オブジェクト指向プログラミングが発明されると、人間の精神はそれと比較されることになったのである。&lt;/p&gt;

&lt;p&gt;多くの場合、オブジェクト指向の方がプログラムが小さくなり、保守が容易であると考えられている。プログラムはクラス群の定義から構成されている。オブジェクト指向言語と一口に言っても、全てをオブジェクトとみなす純粋なオブジェクト指向言語は少ない。例として最初のオブジェクト指向言語 Smalltalk があるが、商業的に成功したとは言いがたい。多くのオブジェクト指向言語は、手続き型プログラミングとオブジェクト指向を融合させたものである。&lt;/p&gt;

&lt;p&gt;オブジェクト指向と手続き型の重要な違いとして、オブジェクト指向では関係データベースにアクセスするにあたって、データモデルのクラス構造へのマッピングが必要である。&lt;/p&gt;

&lt;p&gt;以下にオブジェクト指向と手続き型の言語要素を比較した表を示す:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;手続き型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;オブジェクト指向&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;関数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;メソッド&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;モジュール&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;オブジェクト&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;呼び出し&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;メッセージ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;変数&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;メンバ&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;オブジェクト指向に必要なもの:81f2082d0c43803c7b90cee6328c4723&#34;&gt;オブジェクト指向に必要なもの&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;オブジェクト指向プログラミングとは、オブジェクトと呼ばれる機能の部品でソフトウェアを構成させるものであり、一般的に以下の機能や特徴を活用したプログラミング技法のことをいう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;カプセル化（振る舞いの隠蔽とデータ隠蔽）&lt;/li&gt;
&lt;li&gt;インヘリタンス（継承） &amp;ndash; クラスベースの言語&lt;/li&gt;
&lt;li&gt;ポリモフィズム（多態性、多相性） &amp;ndash; 型付きの言語&lt;/li&gt;
&lt;li&gt;ダイナミックバインディング（動的束縛） &amp;ndash; 動的型付言語&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;この機能を文法的に提供するプログラミング言語は、オブジェクト指向プログラミング言語 (OOPL; object-oriented programming language) と呼ばれる。これらの機能のうち、オブジェクト指向の考え方で不可欠なのは「カプセル化」の機能だけである。&amp;gt;そのため、オブジェクト指向プログラミング言語の中には、カプセル化以外の機能については一部を提供していないものもある。&lt;/p&gt;

&lt;p&gt;ただし、カプセル化（可視性の定義）やポリモフィズムとダイナミックバインディングはオブジェクト指向言語に固有の概念というわけではなく、非オブジェクト指向言語の中にもこの性質を備えるものもある。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;c言語で表す:81f2082d0c43803c7b90cee6328c4723&#34;&gt;C言語で表す&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;カプセル化 ⇒ static変数＆static関数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;インヘリタンス ⇒ 構造体の中にスーパークラスのオブジェクトを含める&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ポリモフィズム ⇒ インターフェースとなる共通の関数ポインタを格納した構造体を作成し、その構造体に格納する関数ポインタをオブジェクト毎に切り替える&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ダイナミックバンディング ⇒ ポリモフィズムの方法と同じようにその場に応じて、オブジェクトに入れるクラスを変更する&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c言語でなぜ可能か:81f2082d0c43803c7b90cee6328c4723&#34;&gt;C言語でなぜ可能か&lt;/h2&gt;

&lt;p&gt;変数しかベンバに持つことのできないCの構造体だが、関数ポインタというテクニックを使えば関数の先頭アドレスを示すことができる&lt;/p&gt;

&lt;h2 id=&#34;参考資料:81f2082d0c43803c7b90cee6328c4723&#34;&gt;参考資料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.livedoor.jp/hiroumauma/archives/1366474.html&#34;&gt;C言語でオブジェクト指向してみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://myenigma.hatenablog.com/entry/20141020/1413796816#1-カプセル化&#34;&gt;C言語によるオブジェクト指向プログラミング &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0&#34;&gt;オブジェクト指向プログラミング-wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C言語による並列処理の勉強をしたかった。</title>
      <link>http://ebxpj6bp.github.io/post/2015-11-03/</link>
      <pubDate>Tue, 03 Nov 2015 16:03:34 +0900</pubDate>
      
      <guid>http://ebxpj6bp.github.io/post/2015-11-03/</guid>
      <description>

&lt;p&gt;C言語による並列処理の勉強をしたかった。備忘録&lt;/p&gt;

&lt;h2 id=&#34;openmpとは:a0a57c1b6e12579fe764acb009917377&#34;&gt;OpenMPとは&lt;/h2&gt;

&lt;p&gt;OpenMPは、並列コンピューティング環境を利用するために用いられる標準化された基盤。OpenMPは主に共有メモリ型並列計算機で用いられる。&lt;/p&gt;

&lt;p&gt;MPIでは明示的にメッセージの交換をプログラム中に記述しなければならないが、OpenMPはOpenMPが使用できない環境では無視されるディレクティブを挿入することによって並列化を行う。このため並列環境と非並列環境でほぼ同一のソースコードを使用できるという利点がある。 また、プラットフォーム固有のスレッドAPIを使わず、コンパイラによって暗黙的に生成されたスレッドプールを利用してタスクを振り分けることになるため、並列プログラムを簡潔に記述できるだけでなく、複数の環境に移植しやすくなる。&lt;/p&gt;

&lt;p&gt;MPIとの比較では、OpenMPは異なるスレッドが同一のデータを同じアドレスで参照できるのに対して、MPIでは明示的にメッセージ交換を行わなければならない。そのためSMP環境においては大きなデータの移動を行なわずにすむので高い効率が期待できる。ただし並列化の効率はコンパイラに依存するのでチューニングによる性能改善がMPIほど高くならないという問題がある。また、OpenMPはMPIに比べてメモリアクセスのローカリティが低くなる傾向があるので、頻繁なメモリアクセスがあるプログラムでは、MPIの方が高速な場合が多い&lt;/p&gt;

&lt;h2 id=&#34;openmpで使われれる指示文:a0a57c1b6e12579fe764acb009917377&#34;&gt;OpenMPで使われれる指示文&lt;/h2&gt;

&lt;p&gt;OpenMPではプログラム内で並列を行いたい場所に対して&lt;code&gt;#pragma&lt;/code&gt;を記述し&lt;code&gt;#pragma omp&lt;/code&gt;の形をとる&lt;/p&gt;

&lt;h3 id=&#34;並列リージョン指示文:a0a57c1b6e12579fe764acb009917377&#34;&gt;並列リージョン指示文&lt;/h3&gt;

&lt;p&gt;#pragma omp parallel&lt;/p&gt;

&lt;h3 id=&#34;処理分散指示文:a0a57c1b6e12579fe764acb009917377&#34;&gt;処理分散指示文&lt;/h3&gt;

&lt;p&gt;#pragma omp for&lt;/p&gt;

&lt;p&gt;#pragma omp sections&lt;/p&gt;

&lt;h3 id=&#34;同期に関する指示文:a0a57c1b6e12579fe764acb009917377&#34;&gt;同期に関する指示文&lt;/h3&gt;

&lt;p&gt;#pragma omp single&lt;/p&gt;

&lt;p&gt;#pragma omp master&lt;/p&gt;

&lt;p&gt;#pragma omp critical&lt;/p&gt;

&lt;p&gt;#pragma omp atomic&lt;/p&gt;

&lt;p&gt;#pragma omp barrier&lt;/p&gt;

&lt;p&gt;#pragma omp ordered&lt;/p&gt;

&lt;p&gt;#pragma omp flush&lt;/p&gt;

&lt;h2 id=&#34;openmpを用いたコード:a0a57c1b6e12579fe764acb009917377&#34;&gt;OpenMPを用いたコード&lt;/h2&gt;

&lt;h3 id=&#34;pragma-omp-parallelの例:a0a57c1b6e12579fe764acb009917377&#34;&gt;#pragma omp parallelの例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;studio.h&amp;gt;
#include &amp;lt;omp.h&amp;gt;
int main(void)
{
    #pragma omp parallel
    {
        printf(&amp;quot;Hello World!\n&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力結果:&lt;/p&gt;

&lt;p&gt;スレッドの数だけHello Worldを出力する&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;pragma-omp-parralel-forの例:a0a57c1b6e12579fe764acb009917377&#34;&gt;#pragma omp parralel forの例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;studio.h&amp;gt;
#include &amp;lt;omp.h&amp;gt;

int main(void)
{
    int i, a[100];
    #pragma omp parallel for
    for(i = 0; i &amp;lt; 100; i++){
        a[i]=0;
    }                   
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出力結果:&lt;/p&gt;

&lt;p&gt;スレッド0番: for(i = 0; i &amp;lt; 25; i++) a[i]=0;&lt;/p&gt;

&lt;p&gt;スレッド1番: for(i = 25; i &amp;lt; 50; i++) a[i]=0;&lt;/p&gt;

&lt;p&gt;スレッド2番: for(i = 50; i &amp;lt; 75; i++) a[i]=0;&lt;/p&gt;

&lt;p&gt;スレッド3番: for(i = 75; i &amp;lt; 100; i++) a[i]=0;&lt;/p&gt;

&lt;h3 id=&#34;ファイルコピーの例:a0a57c1b6e12579fe764acb009917377&#34;&gt;ファイルコピーの例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/uio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#define BUF_SIZE 4096*1024
char buf1[BUF_SIZE];
char buf2[BUF_SIZE];

int main(int argc,char *argv[])
{
    int file_stc,file_dst;
    int size1, size2;
    if( argc != 3){
        printf(&amp;quot;usage: filecopy source-file dest-file\n&amp;quot;)
        return 1;
    }
    file_src=open(argv[1],O_RDONLY); 
    file_dst=open(argv[2],O_WRONLY|O_CREAT|O_TRUNC,S_IREAD|S_IWRITE);
    if( file_src==-1 || file_dst==-1 ){
        printf(&amp;quot;file read/write error\n&amp;quot;);
        return 1;
    }
    size1=read(file_src,buf1,BUF_SIZE);

    #pragma omp parallel sections num_threads(2)
    {
        #pragma omp section
        while(1){
            size2=read(file_src,buf2,BUF_SIZE);

            #pragma omp barrier
            if( size2 &amp;lt;= 0 ) 
                break;
            size1=read(file_src,buf1,BUF_SIZE);

            #pragma omp barrier
            if( size1&amp;lt;=0 ) 
                break;
        }
        #pragma omp section
        while(1){
            write(file_dst,buf1,size1);

            #pragma omp barrier
            if( size2&amp;lt;=0 ) 
                break;
            write(file_dst,buf2,size2);

            #pragma omp barrier
            if( size1&amp;lt;=0 ) break;
        } 
    }
    close(file_src);
    close(file_dst);
    return 0;
}                                                        
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考:a0a57c1b6e12579fe764acb009917377&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/OpenMP&#34;&gt;OpenMP - Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.google.co.jp/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=6&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=0CD8QFjAFahUKEwj1tLi-1_PIAhUFmJQKHSa_CaA&amp;amp;url=http%3A%2F%2Fwww.cc.u-tokyo.ac.jp%2Fsupport%2Fkosyu%2F03%2Fkosyu-openmp_c.pdf&amp;amp;usg=AFQjCNEJGbKtYlh39Etv42TzJpjyI8jDIQ&amp;amp;sig2=lAaDfPR0eogJo1v_3EuR8A&#34;&gt;C 言語による OpenMP 入門 - 東京大学&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Minecraftで出来るFPS RefineFPS</title>
      <link>http://ebxpj6bp.github.io/post/2015-10-12/</link>
      <pubDate>Mon, 12 Oct 2015 09:48:14 +0900</pubDate>
      
      <guid>http://ebxpj6bp.github.io/post/2015-10-12/</guid>
      <description>

&lt;p&gt;RefineFPSについて何が言いたいのかよくわからない記事&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ebxpj6bp.github.io/images/2015-10-12.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;refinefpsとは:0ea62ef95db9728c12a858c5f03ce084&#34;&gt;RefineFPSとは&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;RefineFPS Server とは11月3日にオープンβとしてサービス開始した
Minecraft というサンドボックス型ゲームのマルチサーバーです。
「洗練されたFPSゲーム」をコンセプトに運営しています(鯖名もその通り)。
RefineFPSでは本格的なゲームをユーザーの皆様方に提供しております。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;del&gt;運営が働かないクソ鯖&lt;/del&gt;　民度がとてもよく「ha?」「uza」「shine」がよく飛び交う楽しいFPSサーバーです-　&lt;/p&gt;

&lt;p&gt;武器の種類は大きく分けて8種類「AR, SR, SG, SMG, MG, HG, Grende, Knife」 ゲーム中のインベントリには「AR~MG, HG, Grende, Knife」の4種類が入ります&lt;/p&gt;

&lt;h2 id=&#34;refinefpsの現状:0ea62ef95db9728c12a858c5f03ce084&#34;&gt;RefineFPSの現状&lt;/h2&gt;

&lt;p&gt;2014/12/03 - 2014/12/21 に&lt;a href=&#34;http://fps.mcsv.jp/Event/1stAnniversarySlot&#34;&gt;アニバーサリスロット&lt;/a&gt;イベントが行われたのち約5ヵ月更新なし&lt;/p&gt;

&lt;p&gt;2014/05/07 &lt;a href=&#34;http://fps.mcsv.jp/News/Index/57&#34;&gt;ガチャ&lt;/a&gt;の登場 登場し少し回せただけでイベントではなかった&lt;/p&gt;

&lt;p&gt;2015/08/24 &lt;a href=&#34;http://fps.mcsv.jp/Event/Mallon2015&#34;&gt;栗をくりぃ&lt;/a&gt;約8ヵ月ぶりのイベントが行われた しかし本来であれば09/13まで行われるはずだったが08/27までの短縮になりイベントが行われたのは3日間だった&lt;/p&gt;

&lt;p&gt;2015/10/12 更新なし&lt;/p&gt;

&lt;p&gt;運営増やす予定なし&lt;/p&gt;

&lt;h2 id=&#34;link:0ea62ef95db9728c12a858c5f03ce084&#34;&gt;Link&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://fps.mcsv.jp/&#34;&gt;RefineFPS-HP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/RefineFPS&#34;&gt;RefineFPS-Twitter&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://refinefps.wiki.fc2.com/&#34;&gt;RefineFPS-Wiki&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>