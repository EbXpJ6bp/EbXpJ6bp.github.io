<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Csharp on EbXpJ6bp&#39;s Blog</title>
    <link>http://ebxpj6bp.github.io/tags/csharp/</link>
    <description>Recent content in Csharp on EbXpJ6bp&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Wed, 28 Oct 2015 19:39:58 +0900</lastBuildDate>
    <atom:link href="http://ebxpj6bp.github.io/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C#でSplashWindow(Screen)を表示させる</title>
      <link>http://ebxpj6bp.github.io/post/2015-10-28/</link>
      <pubDate>Wed, 28 Oct 2015 19:39:58 +0900</pubDate>
      
      <guid>http://ebxpj6bp.github.io/post/2015-10-28/</guid>
      <description>

&lt;p&gt;スプラッシュ(スプラッシュスクリーン)を特定処理が終わったら自動的に閉じて切り替えたりする。&lt;/p&gt;

&lt;h2 id=&#34;スプラッシュ-スプラッシュスクリーン-とは:b29053ff5e3dc3ee8ed7aab801e3a548&#34;&gt;スプラッシュ(スプラッシュスクリーン)とは&lt;/h2&gt;

&lt;p&gt;スプラッシュ(スプラッシュスクリーン)は起動時に処理のかかるアプリケーションを起動させる場合、ユーザーの不安を無くすために読み込んでます感を出すために表示されることが多い。基本的に画面全体を覆う大きさではなく、中央に表示される。VisualStudio, OfficeなどMSのアプリには大抵あります。&lt;/p&gt;

&lt;p&gt;WPFにはスプラッシュスクリーンという機能がありますが、素早く表示され初期化が終わった時点で自動的に消えます。これは表示タイミングと表示を消すタイミングを作成側が指定することができません。そこでWindowを作成しそれをスプラッシュスクリーンとして扱いApp.xamlからそれを操作します。&lt;/p&gt;

&lt;h2 id=&#34;code:b29053ff5e3dc3ee8ed7aab801e3a548&#34;&gt;Code&lt;/h2&gt;

&lt;p&gt;App.xaml.cs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class App : Application
{       
    private SplashWindow _splash;
    public SplashWindow Splash { get; private set; }

    public App() : base()
    {
        Startup += Application_Startup;
    }

    private void Application_Startup(object sender, StartupEventArgs e){        
        Splash = new SplashWindow();
        Splash.Show();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MainWindow.xaml.cs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();

        Loaded += MainWindow_Loaded;
    }

    public void MainWindow_Loaded(object sender, RoutedEventArgs e)
    {
        var app = Application.Current as App;
        if (app == null || app.Splash == null) return;
        app.Splash.Close();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;App.xamlでSplashを表示させ、MainWindowがロードし終わった時点でSplashWindowを閉じます。ですがこの閉じる動作は確実に行われるわけではないので不安ならusing等を使うとうまくいくかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;ついで:b29053ff5e3dc3ee8ed7aab801e3a548&#34;&gt;ついで&lt;/h2&gt;

&lt;p&gt;スプラッシュスクリーンを任意のタイミングまで表示させたい場合は&lt;code&gt;System.Threading.Thread.Sleep&lt;/code&gt;を利用しスレッドを無理やり停止させます&lt;/p&gt;

&lt;p&gt;App.xaml&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public partial class App : Application
{
    void App_Startup(object sender, StartupEventArgs e)
    {
        System.Threading.Thread.Sleep(3000);

        Main = new MainWindow();
        Main.Show();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>C#でUpdateCheckをする</title>
      <link>http://ebxpj6bp.github.io/post/2015-10-24/</link>
      <pubDate>Sat, 24 Oct 2015 21:07:25 +0900</pubDate>
      
      <guid>http://ebxpj6bp.github.io/post/2015-10-24/</guid>
      <description>

&lt;p&gt;初めてまじめかもしれない記事&lt;/p&gt;

&lt;p&gt;OneceClickは便利だけどもどうせなら自分で(自動)アップデート機構を作りたいと思い適当に組みました  C#を使っています&lt;/p&gt;

&lt;p&gt;また例外に対し何もしていなかったり非同期ではなかったり初心者ソースになります&lt;/p&gt;

&lt;p&gt;Usingは適宜指定してください&lt;/p&gt;

&lt;h2 id=&#34;アップデートチェックだけ:511268231389866b3cfa797c488c371e&#34;&gt;アップデートチェックだけ&lt;/h2&gt;

&lt;p&gt;起動時にでも仕込ませて置けば十分だと思います。 このバージョンはとりあえず書いてあるファイルをそのまま読み込みその内容がProductVersionと違うかどうかを確認するだけです。&lt;/p&gt;

&lt;p&gt;この方式では通知をするだけです&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string ver;

WebClient wc = new WebClient();

Stream st = wc.OpenRead(&amp;quot;調べるサイトURL&amp;quot;);

StreamReader sr = new StreamReader( st, Encoding.GetEncoding(51932));

ver = sr.ReadToEnd();

st.Close();

wc.Dispose();

if (ver != Application.ProductVersion)

{

    MessageBox.Show(&amp;quot;アップデートが∩(・＿・)∩あるでwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&amp;quot;);

}

else

{
    MessageBox.Show(&amp;quot;アップデートが(・＿・)ないwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&amp;quot;);
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;アップデートチェックをしてその詳細情報を伝える:511268231389866b3cfa797c488c371e&#34;&gt;アップデートチェックをしてその詳細情報を伝える&lt;/h2&gt;

&lt;p&gt;こちらも起動時にでも仕込ませて置けば十分だと思います。 先ほどと違うのはアップデートチェックを行いその情報を取得,通知できるようにします。&lt;/p&gt;

&lt;p&gt;Xml解析を含んでいるのでアップデートチェックを行った後そのままファイルをダウンロードさせることが可能になります。ダウンロードURLが常に同じならこの方式をとる必要はありませんが、Githubにバージョン毎に公開していてそれを利用したい場合はこのようにするのがいいと思います。&lt;/p&gt;

&lt;p&gt;Xml解析の部分は特に初心者感が出てると思いますがご了承ください&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Version = Version情報&lt;/li&gt;
&lt;li&gt;Date = 更新日時&lt;/li&gt;
&lt;li&gt;Url = ダウンロードURL   としています&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;WebClient wc = new WebClient();

byte[] pagedata = wc.DownloadData(&amp;quot;調べるサイトURL&amp;quot;);

Encoding ec = Encoding.UTF8;

//Console.WriteLine(ec.GetString(pagedata));

XmlDocument xdoc = new XmlDocument();

xdoc.LoadXml(ec.GetString(pagedata));

XmlElement root = xdoc.DocumentElement;

XmlNodeList wc = root.SelectNodes(&amp;quot;Updata&amp;quot;);

var version = root.SelectSingleNode(&amp;quot;Version&amp;quot;).InnerText;
var date = root.SelectSingleNode(&amp;quot;Date&amp;quot;).InnerText;
var url = root.SelectSingleNode(&amp;quot;URL&amp;quot;).InnerText;

wc.Dispose();

if (version != Application.ProductVersion)

{

    MessageBox.Show(&amp;quot;アップデートが∩(・＿・)∩あるでwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&amp;quot;);
    Console.WriteLine(&amp;quot;Version:{0} 更新日時:{1} ダウンロードURL:{2}&amp;quot;, version, date, url);
    //ダウンロード, 解凍させ上書きする機構
}

else

{
    MessageBox.Show(&amp;quot;アップデートが(・＿・)ないwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww&amp;quot;);
}   
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;今回解析したXmlの配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;Updata&amp;gt;
    &amp;lt;Version&amp;gt;1.0.0&amp;lt;/Version&amp;gt;
    &amp;lt;Date&amp;gt;2015/0/0&amp;lt;/Date&amp;gt;
    &amp;lt;URL&amp;gt;URL&amp;lt;/URL&amp;gt;
&amp;lt;/Updata&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>